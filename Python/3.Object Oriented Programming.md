<p align='right'><a align="right" href="https://github.com/KIRANKUMAR7296/Library/blob/main/Interview.md">Back to Questions</a></p>

# Object Oriented Programming

- `Analysis` : Understand your **problem** ( **What** do you need to do ? )
- `Design` : Plan your **solution** ( **How** are you going to do it ? )
- `Programming` : **Build** it.

### Approach

- Gather requirements.
- Describe the Application.
- Identify the main object.
- Describe the interactions.
- Create a class diagram.

Structuring a program by bundling related `properties` or `attributes` and `behaviors` into individual `objects`

### Procedural Programming
- Structures a program like a recipe in that it provides a set of steps, in the form of **functions** and **code blocks**, that flow sequentially in order to complete task.

### Class
- `Blueprint` or `template` that describes `attributes` and `method` of an object.
- `Attributes` : Physical properties.
- `Method` : Behavior or action.

Define a `class`

``` Python
class Student:
    pass
```

### `Object`
- `Instance` of a `class` which has `attributes` and `methods`
- When class is defined, only the `description` for an object is defined, no `memory` or `storage` is allocated.

**Characteristics** of `objects` of class :

1. Identity ( What is it ? : class Person ) 
2. Attributes | Properties | Characteristics | Data ( What Describes it ? : Name, Gender, Age, Height, Weight )
3. Behaviour | Action | Operation ( What can it do ? : Read, Write, Walk, Run, Study, Teach )

The concept of `OOP` in focuses on creating **reusable** code | `DRY` ( Don't Repeat Yourself )

### Constructor 
- Automatically invokes whenever an object is created.
- `Default Constructor` : Constructor with `no` parameters | arguments..

### `__init__()`

- Like a constructor method (**Initialize** an **object**)
- Everytime a new object is created, `__init__()` sets the **initial state** of the object.
- Method is called when any new `instance` of an `object`  is created.
- Initialize the `attributes` of the `class`
- You can give any number of `parameters`
- First parameter will always be a variable `self`

### `self`
- Instance methods can `access` attributes and other methods on the same objects.

``` Python
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

``` Python
class Student:

    # Class Attribute (Common Attribute for all Class Instances)
    school_name = "IES GNV"
    
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

Class attributes are defined directly beneath the first line of the class name.
- Must always assigned an **initial value**.

### Instantiate an object
- Process of **creating** an `object` ( Instance of a class ) is called **instantiation**.
- Every new object `instance` is located at a different memory address.
- The process to **create** an `object` is similar to a `function call` (**ObjectName** = **ClassName()**)

### `Methods`
- `Functions` defined inside body of a `class`
- Defines `action` or `behaviour` of an object.

### `APIE`

- `A` : Abstraction
- `P` : Polymorphism
- `I` : Inheritance
- `E` : Encapsulation

### `Base` or `Parent` or `Super` class.

### `Derived` or `Child` or `Sub` class.

### `Abstraction`

- `Show` only important information and `hide` implementation or internal details from users.
- e.g. Mobile can do many things like make a call, take pictures, play games, watch movies, etc.
- It doesn't show the inside process of how its doing the things (Implementation parts are hidden)

### `Polymorphism` (Many Forms)

- Having more than one form.
- Allow to call methods of base class in derived class.
- e.g A person at same time is a father, a husband, an employee and behaves accordingly.
- - Same method name but different attributes and number of parameters.

### `Inheritance`

- `Inheritance` enables us to `create` a new `class` from existing class by adding new functionality to it or by simply modifying it.
- The pre existing class is known as a `Base Class` and the newly defined class is known as a `Derived Class`
- To inherit `__init__()` method of the `parent class` inside derived class, use `super().__init__()`

### `Multiple` Inheritance

- A `class` can be `derived` from more than one `base class`

``` Python
class Base1:
    pass

class Base2:
    pass

class MultiDerived(Base1, Base2):
    pass
```

### `Multi Level` Inheritance
- Inherit from `derived class`
- Features of `base class` and `derived class` are inherited into a `new derived class`

``` Python
class Base:
    pass

class Derived1(Base):
    pass

class Derived2(Derived1):
    pass
```

### `Method Overriding`
- When the `__init__()` method is defined inside `derived` class, it `overrides` the `base` class

``` Python
class Base:
    pass
  
class Derived(Base):
    pass

```

### `Encapsulation`

- Bind together `data`, `attributes` and `methods` ( Class = Data + Attribute + Method )
- `Restrict` access to `methods` and `variables` of class.
- Prevents data from **direct modification**.
- e.g. A company has several departments Production, HR, Accounts, Marketing.
- All these departments makes up a company, and each department has it's own purpose and actions.
- We denote `private attribute` using single underscore `_` or double underscore `__`

### Important Concepts in Class
1. Define a `class`
2. Instantiate an `object` a `class`
3. Use `attributes` and `methods` to define the `properties` and `behaviors` of an object.
4. Use `inheritance` to create `child classes` from a `parent class`
5. Reference a method in a `parent class` using `super()`
6. Check if an `object` inherits from another class using `isinstance()`

### Benefits of Object Oriented Programming
- Makes Program **easy** to understand.
- Class is **sharable**, code can be **reused**.
- Data is **safe** and **secure** with **data abstraction**.

### Operator Overloading in Python
- Same operator behaves differently with different `data types` according to **context**.
- (**+**) Operator will perform **arithmetic addition** on two numbers, **merge** two lists and **concatenate** two strings.
- But it does not performs same operations on **user defined class**
- we need to implement **\_\_add\_\_()** function in the class.

### Overloading Arithmetic and Logical Operators 

| Operator            | Expression	| Special Function        |
| :---                | :---:       | :---:                   |
| Addition            | p1 + p2	    | p1.\_\_add\_\_(p2)      |
| Subtraction         |	p1 - p2	    | p1.\_\_sub\_\_(p2)      | 
| Multiplication      |	p1 * p2	    | p1.\_\_mul\_\_(p2)      | 
| Power               |	p1 ** p2	| p1.\_\_pow\_\_(p2)      |
| Division            |	p1 / p2	    | p1.\_\_truediv\_\_(p2)  |
| Floor Division      |	p1 // p2	| p1.\_\_floordiv\_\_(p2) | 
| Remainder (modulo)  |	p1 % p2	    | p1.\_\_mod\_\_(p2)      |
| Bitwise Left Shift  |	p1 << p2	| p1.\_\_lshift\_\_(p2)   | 
| Bitwise Right Shift | p1 >> p2	| p1.\_\_rshift\_\_(p2)   |
| Bitwise AND         | p1 & p2	    | p1.\_\_and\_\_(p2)      |
| Bitwise OR          | p1 \| p2    | p1.\_\_or\_\_(p2)       |
| Bitwise XOR         |	p1 ^ p2	    | p1.\_\_xor\_\_(p2)      |
| Bitwise NOT         | ~p1	        | p1.\_\_invert\_\_()     |

### Overloading Comparison Operators 

| Operator	               | Expression | Special Functions     |
| :---                     | :---:      | :---:                 |
| Less than	               | p1 < p2	| p1.\_\_lt\_\_(p2)     |
| Less than or equal to    | p1 <= p2	| p1.\_\_le\_\_(p2)     |
| Equal to	               | p1 == p2	| p1.\_\_eq\_\_(p2)     |
| Not equal to	           | p1 != p2	| p1.\_\_ne\_\_(p2)     | 
| Greater than	           | p1 > p2	| p1.\_\_gt\_\_(p2)     |
| Greater than or equal to | p1 >= p2	| p1.\_\_ge\_\_(p2)     |

<p align='right'><a align="right" href="https://github.com/KIRANKUMAR7296/Library/blob/main/Interview.md">Back to Questions</a></p>
